---
    layout: default
    comments: true
    title:  【豆瓣怎么做】CaoE的知识储备篇
---

<h4><strong>{{ page.title }}</strong>&nbsp;&nbsp;<small>{{ page.date | date_to_string }}</small></h4><br />
<p>
    豆瓣怎么做系列文章意在讨论由豆瓣相关人员发布的开源工程代码 <a href="">了解详细</a>
</p>
<br>

<p>
    本篇来看 <a href="https://github.com/douban/CaoE">CaoE</a>
</p>
<p>
    实际上我们不是随意选择 repo 的
</p>
<p>
    CaoE 这个仅仅百行代码的 repo 被选定是因为涉及了明了的进程操作, 代码精炼，涉及很多可拓展知识
</p>
<p>
    我们更希望从简洁精炼的代码中汲取能力 谁不想呢 让更少的代码做更多的事情
</p>

<br>
<h5><strong>知识节点一: fork() </strong></h5>
<p>
    进程的概念不赘述，实际上它是计算机科学中“最深刻最成功的概念之一”(引自《深入理解计算机系统》)
</p>
<p>
    系统函数 fork() 在进程操作中用于创建子进程，子进程会是父进程的复制，用PID来作为区分
</p>
<p>
    fork() 函数的有趣之处在于:
</p>
<p>
    每次调用 fork() 函数将返回两次, 一次返回子进程的PID 另外一次返回 0
</p>
<p>
    因为子进程的PID不可能为 0, 所以两次返回可用于区分当前程序的运行位置（是在父进程中还是在子进程中）
</p>

<br>
<pre>
    PID = os.fork()
    if PID == 0 :
        当前运行于子进程中 (子进程的PID是不可能为 0 )
    else:
        当前运行于父进程中
</pre>

<p>
    fork() 的规则并不难，但使用的时候容易混淆, 作为进程操作基础也不是我们讨论的重点
</p>

<br>
<h5><strong>知识节点二: 系统信号 </strong></h5>
